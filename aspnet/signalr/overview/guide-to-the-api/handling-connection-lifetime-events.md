---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Verstehen und Behandeln von Lebensdauer Verbindungsereignisse in SignalR | Microsoft Docs
author: pfletcher
description: Dieser Artikel beschreibt, wie von der Hubs-API verfügbar gemachten Ereignisse beschrieben.
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/10/2014
ms.topic: article
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 2fd9cafd8d7706807998793c3c39377fe9604266
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/24/2018
ms.locfileid: "28036569"
---
<a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="2fb64-103">Verstehen und Behandeln von Lebensdauer Verbindungsereignisse in SignalR</span><span class="sxs-lookup"><span data-stu-id="2fb64-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>
====================
<span data-ttu-id="2fb64-104">durch [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="2fb64-104">by [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span></span>

> <span data-ttu-id="2fb64-105">Dieser Artikel enthält eine Übersicht über die SignalR erneuten Herstellen einer Verbindung und die Trennung der Ereignisse, die Sie behandeln können, und Timeouts und Keepalive-Einstellungen, die Sie konfigurieren können.</span><span class="sxs-lookup"><span data-stu-id="2fb64-105">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
> 
> <span data-ttu-id="2fb64-106">Der Artikel wird davon ausgegangen, dass Sie bereits einige Kenntnisse SignalR und Lebensdauer Verbindungsereignisse haben.</span><span class="sxs-lookup"><span data-stu-id="2fb64-106">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="2fb64-107">Eine Einführung zu SignalR finden Sie unter [Einführung in SignalR](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="2fb64-107">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="2fb64-108">Listen von Verbindungsereignissen-Lebensdauer finden Sie unter den folgenden Ressourcen:</span><span class="sxs-lookup"><span data-stu-id="2fb64-108">For lists of connection lifetime events, see the following resources:</span></span>
> 
> - [<span data-ttu-id="2fb64-109">Behandeln von Lebensdauer Verbindungsereignisse in der Hub-Klasse</span><span class="sxs-lookup"><span data-stu-id="2fb64-109">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="2fb64-110">Behandeln von Lebensdauer Verbindungsereignisse in JavaScript-clients</span><span class="sxs-lookup"><span data-stu-id="2fb64-110">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="2fb64-111">Behandeln von Lebensdauer Verbindungsereignisse in .NET clients</span><span class="sxs-lookup"><span data-stu-id="2fb64-111">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
> 
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="2fb64-112">In diesem Thema verwendeten Versionen der Software</span><span class="sxs-lookup"><span data-stu-id="2fb64-112">Software versions used in this topic</span></span>
> 
> 
> - [<span data-ttu-id="2fb64-113">Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="2fb64-113">Visual Studio 2013</span></span>](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - <span data-ttu-id="2fb64-114">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="2fb64-114">.NET 4.5</span></span>
> - <span data-ttu-id="2fb64-115">SignalR Version 2</span><span class="sxs-lookup"><span data-stu-id="2fb64-115">SignalR version 2</span></span>
>   
> 
> 
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="2fb64-116">Frühere Versionen dieses Themas</span><span class="sxs-lookup"><span data-stu-id="2fb64-116">Previous versions of this topic</span></span>
> 
> <span data-ttu-id="2fb64-117">Informationen zu früheren Versionen von SignalR finden Sie unter [ältere Versionen von SignalR](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="2fb64-117">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
> 
> ## <a name="questions-and-comments"></a><span data-ttu-id="2fb64-118">Fragen und Kommentare</span><span class="sxs-lookup"><span data-stu-id="2fb64-118">Questions and comments</span></span>
> 
> <span data-ttu-id="2fb64-119">Lassen Sie Sie Feedback auf wie in diesem Lernprogramm mögen und was wir in den Kommentaren am unteren Rand der Seite verbessern können.</span><span class="sxs-lookup"><span data-stu-id="2fb64-119">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="2fb64-120">Wenn Sie Fragen, die nicht direkt mit dem Lernprogramm verknüpft sind haben, bereitstellen können, die [ASP.NET SignalR-Forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) oder [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="2fb64-120">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>


## <a name="overview"></a><span data-ttu-id="2fb64-121">Übersicht</span><span class="sxs-lookup"><span data-stu-id="2fb64-121">Overview</span></span>

<span data-ttu-id="2fb64-122">Dieser Artikel enthält folgende Abschnitte:</span><span class="sxs-lookup"><span data-stu-id="2fb64-122">This article contains the following sections:</span></span>

- [<span data-ttu-id="2fb64-123">Verbindung Lebensdauer Terminologie und Szenarien</span><span class="sxs-lookup"><span data-stu-id="2fb64-123">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="2fb64-124">SignalR-Verbindungen, transportverbindungen und physische Verbindungen</span><span class="sxs-lookup"><span data-stu-id="2fb64-124">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="2fb64-125">Transport Trennung Szenarien</span><span class="sxs-lookup"><span data-stu-id="2fb64-125">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="2fb64-126">Trennung von Clientszenarien</span><span class="sxs-lookup"><span data-stu-id="2fb64-126">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="2fb64-127">Szenarien für die Trennung von Server</span><span class="sxs-lookup"><span data-stu-id="2fb64-127">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="2fb64-128">Einstellungen für Timeouts und "Keepalive"</span><span class="sxs-lookup"><span data-stu-id="2fb64-128">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="2fb64-129">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="2fb64-129">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="2fb64-130">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="2fb64-130">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="2fb64-131">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="2fb64-131">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="2fb64-132">So ändern Sie die Einstellungen für Timeouts und "Keepalive"</span><span class="sxs-lookup"><span data-stu-id="2fb64-132">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="2fb64-133">Gewusst wie: Benachrichtigung des Benutzers zu trennen</span><span class="sxs-lookup"><span data-stu-id="2fb64-133">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="2fb64-134">Wiederherstellen der Verbindung fortlaufend</span><span class="sxs-lookup"><span data-stu-id="2fb64-134">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="2fb64-135">Einen Client im Servercode Trennen der Verbindung</span><span class="sxs-lookup"><span data-stu-id="2fb64-135">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="2fb64-136">Ermitteln Sie den Grund für eine Trennung von</span><span class="sxs-lookup"><span data-stu-id="2fb64-136">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="2fb64-137">Links zu API-Referenzthemen sind auf die .NET 4.5-Version der API.</span><span class="sxs-lookup"><span data-stu-id="2fb64-137">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="2fb64-138">Wenn Sie .NET 4 verwenden, finden Sie unter [.NET 4-Version der API-Themen](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="2fb64-138">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="2fb64-139">Verbindung Lebensdauer Terminologie und Szenarien</span><span class="sxs-lookup"><span data-stu-id="2fb64-139">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="2fb64-140">Die `OnReconnected` -Ereignishandler in einer SignalR-Hubs kann direkt nach dem Ausführen `OnConnected` aber nicht nach `OnDisconnected` für einen angegebenen Client.</span><span class="sxs-lookup"><span data-stu-id="2fb64-140">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="2fb64-141">Der Grund, dass Sie eine erneute Verbindung ohne eine Trennung haben können ist, dass es gibt mehrere Möglichkeiten, in denen das Wort "Verbindung", die in SignalR verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="2fb64-141">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="2fb64-142">SignalR-Verbindungen, transportverbindungen und physische Verbindungen</span><span class="sxs-lookup"><span data-stu-id="2fb64-142">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="2fb64-143">In diesem Artikel wird unterschieden zwischen *SignalR-Verbindungen*, *transport Verbindungen*, und *physische Verbindungen*:</span><span class="sxs-lookup"><span data-stu-id="2fb64-143">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="2fb64-144">**SignalR-Verbindung** bezieht sich auf eine logische Beziehung zwischen einem Client und Server-URL, von der SignalR-API verwaltet und durch eine Verbindungs­ID eindeutig identifiziert.</span><span class="sxs-lookup"><span data-stu-id="2fb64-144">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="2fb64-145">Die Daten über diese Beziehung werden von SignalR verwaltet und werden verwendet, um keine transportverbindung herstellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-145">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="2fb64-146">Die Beziehungsenden und SignalR verwirft der Daten, wenn der Client Ruft die `Stop` -Methode oder ein Zeitlimit erreicht ist, während SignalR versucht, eine transportverbindung getrennt wiederherstellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-146">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="2fb64-147">**Transportieren von Verbindung** bezieht sich auf eine logische Beziehung zwischen einem Client und einem Server, die von einer der vier Transport APIs verwaltet: WebSockets, vom Server gesendeten Ereignisse forever frame oder lange abrufen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-147">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="2fb64-148">SignalR verwendet den Transport-API, um eine transportverbindung zu erstellen, und die Transport-API, hängt das Vorhandensein einer physischen Netzwerk-Verbindung für die transportverbindung zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-148">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="2fb64-149">Die transportverbindung endet, wenn SignalR diese beendet wird oder wenn der Transport API erkennt, dass die physische Verbindung unterbrochen wird.</span><span class="sxs-lookup"><span data-stu-id="2fb64-149">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="2fb64-150">**Physische Verbindung** bezieht sich auf die physischen Netzwerklinks--Kabel, WLAN-Signale, Router usw. –, die die Kommunikation zwischen einem Clientcomputer und einem Servercomputer zu erleichtern.</span><span class="sxs-lookup"><span data-stu-id="2fb64-150">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="2fb64-151">Muss die physische Verbindung vorhanden, damit keine transportverbindung herstellen, und eine transportverbindung hergestellt werden muss, um eine SignalR-Verbindung herstellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-151">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="2fb64-152">Allerdings endet unterbrechen die physische Verbindung immer sofort die transportverbindung oder SignalR-Verbindung nicht wie weiter unten in diesem Thema erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="2fb64-152">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="2fb64-153">In der folgenden Abbildung die SignalR-Verbindung wird durch die Hubs-API und die Ebene "persistentconnection" API SignalR dargestellt, die transportverbindung wird durch die Transporte Ebene dargestellt und die physische Verbindung wird dargestellt, durch die Linien zwischen dem server und den Clients.</span><span class="sxs-lookup"><span data-stu-id="2fb64-153">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR-Architekturdiagramm](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="2fb64-155">Beim Aufrufen der `Start` Methode in einer SignalR-Client bereitgestellt SignalR-Clientcode mit den Informationen, die es benötigt, um eine physische Verbindung mit einem Server herzustellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-155">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="2fb64-156">SignalR-Clientcode verwendet diese Informationen stellen eine HTTP-Anforderung, und stellen eine physische Verbindung, die eines der vier Transportmethoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="2fb64-156">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="2fb64-157">Wenn der transportverbindung ein Fehler auftritt oder der Server ausfällt, behoben nicht die SignalR-Verbindung sofort, da der Client immer die Informationen, die es muss sich noch um eine neue transportverbindung auf dieselbe URL SignalR automatisch erneut herzustellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-157">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="2fb64-158">In diesem Szenario kein Eingriff seitens der Anwendung beteiligt ist, und wenn die SignalR-Clientcode eine neue transportverbindung hergestellt wird, wird es eine neue SignalR-Verbindung nicht gestartet.</span><span class="sxs-lookup"><span data-stu-id="2fb64-158">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="2fb64-159">Die Kontinuität der SignalR-Verbindung wird in der Faktentabelle berücksichtigt, die die Verbindungs-ID, die erstellt wird, beim Aufrufen der `Start` -Methode, ändert sich nicht.</span><span class="sxs-lookup"><span data-stu-id="2fb64-159">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="2fb64-160">Die `OnReconnected` -Ereignishandler auf dem Hub, das ausgeführt wird, wenn eine transportverbindung automatisch wieder hergestellt ist, nach der unterbrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="2fb64-160">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="2fb64-161">Die `OnDisconnected` -Ereignishandler ausgeführt wird, am Ende einer SignalR-Verbindung.</span><span class="sxs-lookup"><span data-stu-id="2fb64-161">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="2fb64-162">Eine SignalR-Verbindung kann in einem der folgenden Methoden beenden:</span><span class="sxs-lookup"><span data-stu-id="2fb64-162">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="2fb64-163">Wenn der Client Ruft die `Stop` -Methode, wird eine abbruchmeldung an den Server gesendet, und sowohl Client-als auch die SignalR-Verbindung sofort beendet.</span><span class="sxs-lookup"><span data-stu-id="2fb64-163">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="2fb64-164">Nach der Verbindung zwischen Client und Server unterbrochen wird, versucht der Client eine Verbindung herzustellen, und der Server wartet des Clients eine Verbindung herzustellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-164">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="2fb64-165">Wenn die Versuche der verbindungsherstellung nicht erfolgreich sind, und das Timeout für die Trennung der Verbindung beendet, beenden Sie sowohl Client-als auch die SignalR-Verbindung.</span><span class="sxs-lookup"><span data-stu-id="2fb64-165">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="2fb64-166">Der Client beendet, erneut eine Verbindung herstellen möchten, und der Server frei, der seine Darstellung des SignalR-Verbindung.</span><span class="sxs-lookup"><span data-stu-id="2fb64-166">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="2fb64-167">Wenn der Client beendet ohne Möglichkeit zum Aufrufen der `Stop` -Methode, die der Server wartet, für den Client erneut eine Verbindung herzustellen, und beendet dann die SignalR-Verbindung, nachdem das Timeout für die Verbindung trennen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-167">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="2fb64-168">Wenn der Server beendet wird, versucht der Client eine Verbindung herzustellen (die transportverbindung neu erstellen), und beendet dann die SignalR-Verbindung, nachdem das Timeout für die Verbindung trennen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-168">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="2fb64-169">Wenn keine Verbindung Probleme auftreten, und die benutzeranwendung beendet die SignalR-Verbindung durch Aufrufen der `Stop` -Methode, die SignalR-Verbindung und die transportverbindung beginnen und enden an zur gleichen Zeit.</span><span class="sxs-lookup"><span data-stu-id="2fb64-169">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="2fb64-170">In den folgenden Abschnitten werden bei der anderen Szenarien ausführlicher beschrieben.</span><span class="sxs-lookup"><span data-stu-id="2fb64-170">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="2fb64-171">Transport Trennung Szenarien</span><span class="sxs-lookup"><span data-stu-id="2fb64-171">Transport disconnection scenarios</span></span>

<span data-ttu-id="2fb64-172">Physische Verbindungen möglicherweise langsam, oder es liegen Unterbrechungen in Verbindung.</span><span class="sxs-lookup"><span data-stu-id="2fb64-172">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="2fb64-173">Abhängig von Faktoren wie z. B. die Länge der Unterbrechung könnten die transportverbindung abgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="2fb64-173">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="2fb64-174">SignalR versucht, die transportverbindung erneut herzustellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-174">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="2fb64-175">In einigen Fällen die transportverbindung API erkennt die Unterbrechung und löscht die transportverbindung und SignalR in Erfahrung gebracht, sofort, dass die Verbindung unterbrochen wird.</span><span class="sxs-lookup"><span data-stu-id="2fb64-175">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="2fb64-176">In anderen Szenarien sofort weder die transportverbindung API noch SignalR Beachten Sie, dass die Konnektivität unterbrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="2fb64-176">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="2fb64-177">Für alle Transporte mit Ausnahme von langen abruftransports SignalR-Client verwendet eine Funktion namens *"Keepalive"* zum Verlust der Verbindung zu überprüfen, die der Transport-API kann nicht erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="2fb64-177">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="2fb64-178">Informationen zu lange Abruf-Verbindungen finden Sie unter [Einstellungen für Timeouts und Keepalive](#timeoutkeepalive) weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="2fb64-178">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="2fb64-179">Wenn eine Verbindung inaktiv ist, sendet in regelmäßigen Abständen der Server ein Keepalive-Paket an den Client.</span><span class="sxs-lookup"><span data-stu-id="2fb64-179">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="2fb64-180">Ab dem Datum, an das in diesem Artikel geschrieben wird, ist das Standardintervall 10 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="2fb64-180">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="2fb64-181">Durch diese Pakete überwachen, können Clients erkennen, liegt ein Verbindungsproblem.</span><span class="sxs-lookup"><span data-stu-id="2fb64-181">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="2fb64-182">Wenn ein Keepalive-Paket nicht empfangen wird, wenn davon ausgegangen, vorausgesetzt nach kurzer Zeit des Clients Verbindungsprobleme wie dies darauf oder Unterbrechungen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-182">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="2fb64-183">Wenn "Keepalive" noch nicht nach einem längeren Zeitraum empfangen wird, nimmt der Client an, dass die Verbindung wurde gelöscht, und sie beginnt, erneut eine Verbindung herstellen möchten.</span><span class="sxs-lookup"><span data-stu-id="2fb64-183">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="2fb64-184">Das folgende Diagramm veranschaulicht die Client-als auch Ereignisse, die in einem typischen Szenario ausgelöst werden, wenn Probleme mit der physischen Verbindung, die vom Transport API sofort erkannt werden.</span><span class="sxs-lookup"><span data-stu-id="2fb64-184">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="2fb64-185">Das Diagramm bezieht sich auf den folgenden Umständen:</span><span class="sxs-lookup"><span data-stu-id="2fb64-185">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="2fb64-186">Die Transportmethode ist WebSockets, forever Frame oder Server gesendete Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="2fb64-186">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="2fb64-187">Es gibt unterschiedliche Zeiträume, in die physische Netzwerkverbindung unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-187">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="2fb64-188">Der Transport-API wird, beachten Sie die Unterbrechung daher SignalR auf der Keepalive-Funktionalität zu erkennen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-188">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Transport Trennvorgänge](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="2fb64-190">Wenn der Client wechselt in den Modus Verbindung jedoch eine transportverbindung innerhalb der Timeoutgrenze Trennen der Verbindung kann nicht erstellt werden, beendet der Server die SignalR-Verbindung an.</span><span class="sxs-lookup"><span data-stu-id="2fb64-190">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="2fb64-191">In diesem Fall wird der Server führt des Hubs `OnDisconnected` -Methode und Warteschlangen ein Trennen-Nachricht an den Client gesendet werden soll, für den Fall, dass der Client verwaltet werden, zu einem späteren Zeitpunkt eine Verbindung herstellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-191">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="2fb64-192">Wenn der Client dann verbunden, erhält Sie den trennungsbefehl und ruft die `Stop` Methode.</span><span class="sxs-lookup"><span data-stu-id="2fb64-192">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="2fb64-193">In diesem Szenario `OnReconnected` wird nicht ausgeführt werden, wenn der Client erneut eine Verbindung herstellt, und `OnDisconnected` wird nicht ausgeführt werden, wenn der Client ruft `Stop`.</span><span class="sxs-lookup"><span data-stu-id="2fb64-193">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="2fb64-194">Das folgende Diagramm veranschaulicht dieses Szenario.</span><span class="sxs-lookup"><span data-stu-id="2fb64-194">The following diagram illustrates this scenario.</span></span>

![Transport-Unterbrechungen - Server-Timeouts](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="2fb64-196">Die SignalR-Verbindung Lebensdauer-Ereignisse, die möglicherweise auf dem Client ausgelöst werden, sind die folgenden:</span><span class="sxs-lookup"><span data-stu-id="2fb64-196">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="2fb64-197">`ConnectionSlow`Client-Ereignis.</span><span class="sxs-lookup"><span data-stu-id="2fb64-197">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="2fb64-198">Ausgelöst, wenn Sie ein vordefinierten Anteil des Timeoutzeitraums "Keepalive" wurde seit der letzten Meldung übergeben oder "Keepalive" Ping empfangen wurde.</span><span class="sxs-lookup"><span data-stu-id="2fb64-198">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="2fb64-199">Das "Keepalive" Warnung Standardtimeout ist 2/3 des Timeouts "Keepalive".</span><span class="sxs-lookup"><span data-stu-id="2fb64-199">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="2fb64-200">Das "Keepalive" Timeout beträgt 20 Sekunden, damit bei etwa 13 Sekunden die Warnung auftritt.</span><span class="sxs-lookup"><span data-stu-id="2fb64-200">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="2fb64-201">Standardmäßig sendet der Server "Keepalive" Pings alle 10 Sekunden, und wird vom Client nach "Keepalive" Ping über alle 2 Sekunden (ein Drittel des Unterschieds zwischen den Timeoutwert "Keepalive" und die Warnung "Keepalive" Timeoutwert).</span><span class="sxs-lookup"><span data-stu-id="2fb64-201">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="2fb64-202">Wenn der API-Transport eine Trennung bewusst ist, möglicherweise SignalR die Trennung der Verbindung informiert werden, bevor das Timeout Warnung für die "Keepalive" übergeben.</span><span class="sxs-lookup"><span data-stu-id="2fb64-202">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="2fb64-203">In diesem Fall die `ConnectionSlow` Ereignis nicht ausgelöst, und SignalR wurde direkt an die `Reconnecting` Ereignis.</span><span class="sxs-lookup"><span data-stu-id="2fb64-203">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="2fb64-204">`Reconnecting`Client-Ereignis.</span><span class="sxs-lookup"><span data-stu-id="2fb64-204">`Reconnecting` client event.</span></span>

    <span data-ttu-id="2fb64-205">Wird ausgelöst, wenn (a) der Transport API erkennt, dass die Verbindung unterbrochen ist, wird das Timeout für (b) die Keepalive seit der letzten Nachricht verstrichen oder "Keepalive" Ping wurde empfangen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-205">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="2fb64-206">Der Clientcode SignalR beginnt, erneut eine Verbindung herstellen möchten.</span><span class="sxs-lookup"><span data-stu-id="2fb64-206">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="2fb64-207">Sie können dieses Ereignis behandeln, wenn Sie möchten die Anwendung bestimmte Aktionen ausführen, wenn der transportverbindung getrennt wird.</span><span class="sxs-lookup"><span data-stu-id="2fb64-207">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="2fb64-208">Das Standardtimeout für "Keepalive" ist derzeit 20 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="2fb64-208">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="2fb64-209">Wenn der Clientcode versucht, eine hubmethode aufrufen, während SignalR befindet sich im Modus erneut zu verbinden, versucht der SignalR beim Senden des Befehls.</span><span class="sxs-lookup"><span data-stu-id="2fb64-209">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="2fb64-210">In den meisten Fällen, solche ist nicht möglich, aber unter bestimmten Umständen sie zwar erfolgreich sein.</span><span class="sxs-lookup"><span data-stu-id="2fb64-210">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="2fb64-211">Für verwendet den Server gesendete Ereignisse, forever Frame, und lange Abruf Transporte SignalR zwei Kommunikationskanäle eine, die vom Client verwendet, um Nachrichten zu senden und eine, die zum Empfangen von Nachrichten verwendet.</span><span class="sxs-lookup"><span data-stu-id="2fb64-211">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="2fb64-212">Der Kanal, der für den Empfang verwendet ist die dauerhaft geöffnet, und ist dasjenige, das geschlossen wird, wenn die physische Verbindung unterbrochen wird.</span><span class="sxs-lookup"><span data-stu-id="2fb64-212">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="2fb64-213">Der Kanal für das Senden bleibt verfügbar ist, verwendet werden, wenn physische Verbindung wiederhergestellt wird, ein Methodenaufruf vom Client zum Server erfolgreich möglicherweise vor der Receive-Kanal hergestellt wurde.</span><span class="sxs-lookup"><span data-stu-id="2fb64-213">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="2fb64-214">Der Rückgabewert würde nicht empfangen werden, bis den Kanal, der zum Empfangen von SignalR erneut geöffnet.</span><span class="sxs-lookup"><span data-stu-id="2fb64-214">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="2fb64-215">`Reconnected`Client-Ereignis.</span><span class="sxs-lookup"><span data-stu-id="2fb64-215">`Reconnected` client event.</span></span>

    <span data-ttu-id="2fb64-216">Wird ausgelöst, wenn die transportverbindung hergestellt wird.</span><span class="sxs-lookup"><span data-stu-id="2fb64-216">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="2fb64-217">Die `OnReconnected` -Ereignishandler auf dem Hub wird ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="2fb64-217">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="2fb64-218">`Closed`Clientereignis (`disconnected` Ereignis in JavaScript).</span><span class="sxs-lookup"><span data-stu-id="2fb64-218">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="2fb64-219">Wird ausgelöst, wenn der Disconnect-Timeout abläuft, während die SignalR-Clientcode versucht, erneut eine Verbindung herstellen, nachdem die transportverbindung verloren ging.</span><span class="sxs-lookup"><span data-stu-id="2fb64-219">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="2fb64-220">Trennen Sie die Standardeinstellung beträgt 30 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="2fb64-220">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="2fb64-221">(Dieses Ereignis wird auch ausgelöst, wenn die Verbindung beendet, da die `Stop` -Methode aufgerufen wird.)</span><span class="sxs-lookup"><span data-stu-id="2fb64-221">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="2fb64-222">Transport Verbindung Unterbrechungen, die nicht vom Transport API erkannt werden und nicht den Empfang von "Keepalive" Pings vom Server länger als das "Keepalive" Warnung Zeitlimit verzögern können beliebige Verbindung Lebensdauerereignisse ausgelöst werden nicht führen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-222">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="2fb64-223">Einigen netzwerkumgebungen absichtlich Schließen von Verbindungen im Leerlauf, und eine Funktion mit dem Keepalive-Pakete, zu unterstützen, dies durch Infrastrukturcode zu verhindern, die diese Netzwerke darüber informiert, dass eine SignalR-Verbindung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="2fb64-223">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="2fb64-224">In Extremfällen der Standardrate von Keepalive Pings genug, um zu verhindern, dass geschlossene Verbindungen möglicherweise nicht.</span><span class="sxs-lookup"><span data-stu-id="2fb64-224">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="2fb64-225">In diesem Fall können Sie "Keepalive" Pings häufiger Versand konfigurieren.</span><span class="sxs-lookup"><span data-stu-id="2fb64-225">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="2fb64-226">Weitere Informationen finden Sie unter [Einstellungen für Timeouts und Keepalive](#timeoutkeepalive) weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="2fb64-226">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="2fb64-227">**Wichtige**: die Abfolge der Ereignisse, die hier beschriebenen ist nicht garantiert.</span><span class="sxs-lookup"><span data-stu-id="2fb64-227">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="2fb64-228">SignalR wird jeder Versuch unternommen, Verbindung Lebensdauer Auslösen von Ereignissen in einer vorhersagbaren Weise gemäß diesem Schema, aber es gibt viele Variationen von Netzwerkereignisse und viele Möglichkeiten, die in denen zugrunde liegenden Communications-Frameworks wie z. B. Transport APIs handhaben.</span><span class="sxs-lookup"><span data-stu-id="2fb64-228">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="2fb64-229">Z. B. die `Reconnected` Ereignis möglicherweise nicht ausgelöst, wenn der Client die Verbindung wiederherstellt, oder die `OnConnected` Ereignishandler auf dem Server kann ausgeführt werden, wenn der Versuch zum Herstellen einer Verbindung nicht erfolgreich ist.</span><span class="sxs-lookup"><span data-stu-id="2fb64-229">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="2fb64-230">Dieses Thema beschreibt nur die Effekte, die normalerweise durch bestimmte normalen Umständen erstellt werden würde.</span><span class="sxs-lookup"><span data-stu-id="2fb64-230">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="2fb64-231">Trennung von Clientszenarien</span><span class="sxs-lookup"><span data-stu-id="2fb64-231">Client disconnection scenarios</span></span>

<span data-ttu-id="2fb64-232">Führt in ein Browserclient SignalR-Clientcode, der eine SignalR-Verbindung verwaltet in der JavaScript-Kontext einer Webseite.</span><span class="sxs-lookup"><span data-stu-id="2fb64-232">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="2fb64-233">Die hat, warum die SignalR-Verbindung wurde die to beim Navigieren von einer Seite zu einem anderen und des Warum stehen Ihnen mehrere Verbindungen mit mehreren Verbindungs-IDs, wenn Sie mehrere Browserfenstern oder Registerkarten eine Verbindung herstellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-233">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="2fb64-234">Wenn der Benutzer ein Browserfenster oder Tabstopp schließt, oder zu einer neuen Seite navigiert oder die Seite aktualisiert wird, die SignalR-Verbindung sofort beendet, da SignalR-Clientcode für Sie und ruft diese Browser-Ereignis behandelt die `Stop` Methode.</span><span class="sxs-lookup"><span data-stu-id="2fb64-234">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="2fb64-235">In diesen Szenarien oder in einer beliebigen Clientplattform, wenn die Anwendung aufruft der `Stop` -Methode, die `OnDisconnected` -Ereignishandler wird sofort ausgeführt, auf dem Server und der Client löst die `Closed` Ereignis (das Ereignis wird mit dem Namen `disconnected` in JavaScript).</span><span class="sxs-lookup"><span data-stu-id="2fb64-235">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="2fb64-236">Wenn eine Clientanwendung oder der Computer, den Ausführung unter abstürzt oder in den Ruhezustand versetzt (z. B. wenn der Benutzer auf den Laptop schließt), wird der Server nicht zu, was passiert ist informiert.</span><span class="sxs-lookup"><span data-stu-id="2fb64-236">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="2fb64-237">Im Hinblick auf der Server bekannt ist, der Verlust des Clients möglicherweise aufgrund einer Unterbrechung der Netzwerkverbindung, und der Client eine Verbindung herzustellen versucht möglicherweise.</span><span class="sxs-lookup"><span data-stu-id="2fb64-237">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="2fb64-238">Aus diesem Grund in diesen Szenarien, die der Server wartet, um dem Client eine Möglichkeit, erneut eine Verbindung herzustellen, geben und `OnDisconnected` wird nicht ausgeführt, bis das Timeout für die Verbindung trennen (ungefähr 30 Sekunden in der Standardeinstellung) abläuft.</span><span class="sxs-lookup"><span data-stu-id="2fb64-238">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="2fb64-239">Das folgende Diagramm veranschaulicht dieses Szenario.</span><span class="sxs-lookup"><span data-stu-id="2fb64-239">The following diagram illustrates this scenario.</span></span>

![Fehler bei der Computer.](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="2fb64-241">Szenarien für die Trennung von Server</span><span class="sxs-lookup"><span data-stu-id="2fb64-241">Server disconnection scenarios</span></span>

<span data-ttu-id="2fb64-242">Wenn ein Server ausfällt--neu gestartet wurde, ein Fehler auftritt, wird die app-Domäne verwendet, usw. – möglicherweise ist das Ergebnis ähnelt eine unterbrochene Verbindung oder API-Transport und SignalR möglicherweise sofort zu wissen, dass der Server nicht mehr vorhanden ist, und SignalR kann beispielsweise versuchen, ohne eine Verbindung zu beginnen. durch das Auslösen der `ConnectionSlow` Ereignis.</span><span class="sxs-lookup"><span data-stu-id="2fb64-242">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="2fb64-243">Wenn der Client wechselt in den Modus Wiederherstellen der Verbindung und der Server wird wiederhergestellt oder erneut startet oder einen neuen Server online geschaltet wird vor Ablauf des Timeouts trennen, wird der Client mit dem wiederhergestellten oder neuen Verbindung wiederherstellen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-243">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="2fb64-244">In diesem Fall weiterhin den SignalR-Verbindung auf dem Client und dem `Reconnected` Ereignis wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="2fb64-244">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="2fb64-245">Auf dem ersten Server `OnDisconnected` nie ausgeführt wird, und klicken Sie auf dem neuen Server `OnReconnected` ausgeführt wird, obwohl `OnConnected` nie für diesen Client auf diesem Server, bevor Sie ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="2fb64-245">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="2fb64-246">(Der Effekt ist gleich, wenn der Client mit dem gleichen Server nach einem Neustart oder das app-Anwendungsdomänen-Wiederverwendung, erneut eine Verbindung herstellt, da beim Neustart des Servers es keine vorherige Verbindungsaktivität Hauptspeicher.) Im folgende Diagramm wird davon ausgegangen, dass der Transport API sofort, beachten Sie die Verbindung unterbrochen wird daher die `ConnectionSlow` Ereignis wird nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="2fb64-246">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Serverfehler und erneuten Herstellen einer Verbindung](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="2fb64-248">Wenn ein Server nicht innerhalb des Zeitlimits Disconnect verfügbar ist, endet die SignalR-Verbindung.</span><span class="sxs-lookup"><span data-stu-id="2fb64-248">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="2fb64-249">In diesem Szenario die `Closed` Ereignis (`disconnected` in JavaScript-Clients) für den Client ausgelöst wird, aber `OnDisconnected` wird nie aufgerufen werden, auf dem Server.</span><span class="sxs-lookup"><span data-stu-id="2fb64-249">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="2fb64-250">Im folgende Diagramm wird davon ausgegangen, dass der Transport API aktuell ist nicht beachten Sie die Verbindung unterbrochen ist, damit es von SignalR Keepalive-Funktionalität erkannt wird und die `ConnectionSlow` Ereignis wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="2fb64-250">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Serverfehler und timeout](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="2fb64-252">Einstellungen für Timeouts und "Keepalive"</span><span class="sxs-lookup"><span data-stu-id="2fb64-252">Timeout and keepalive settings</span></span>

<span data-ttu-id="2fb64-253">Die Standardeinstellung `ConnectionTimeout`, `DisconnectTimeout`, und `KeepAlive` Werte in den meisten Szenarien geeignet sind, jedoch kann geändert werden, wenn Ihre Umgebung spezielle Anforderungen hat.</span><span class="sxs-lookup"><span data-stu-id="2fb64-253">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="2fb64-254">Wenn Ihre Netzwerkumgebung Verbindungen geschlossen werden, die 5 Sekunden lang im Leerlauf befinden, müssen Sie z. B. möglicherweise den Keepalive-Wert zu verringern.</span><span class="sxs-lookup"><span data-stu-id="2fb64-254">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="2fb64-255">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="2fb64-255">ConnectionTimeout</span></span>

<span data-ttu-id="2fb64-256">Diese Einstellung steht für die Zeitspanne, um eine transportverbindung zu öffnen und wartet auf eine Antwort vor dem Schließen und eine neue Verbindung öffnen lassen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-256">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="2fb64-257">Der Standardwert ist 110 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="2fb64-257">The default value is 110 seconds.</span></span>

<span data-ttu-id="2fb64-258">Diese Einstellung gilt nur beim Keepalive-Funktionalität deaktiviert die bezieht sich normalerweise nur auf den langen, abruftransport.</span><span class="sxs-lookup"><span data-stu-id="2fb64-258">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="2fb64-259">Das folgende Diagramm veranschaulicht die Auswirkungen dieser Einstellung auf einen Long-Wert abrufen transportverbindung.</span><span class="sxs-lookup"><span data-stu-id="2fb64-259">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Lange Abruf-transportverbindung](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="2fb64-261">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="2fb64-261">DisconnectTimeout</span></span>

<span data-ttu-id="2fb64-262">Diese Einstellung steht für die Zeitspanne, die gewartet wird, nachdem eine transportverbindung verloren, vor dem Auslösen gegangen ist der `Disconnected` Ereignis.</span><span class="sxs-lookup"><span data-stu-id="2fb64-262">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="2fb64-263">Der Standardwert ist 30 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="2fb64-263">The default value is 30 seconds.</span></span> <span data-ttu-id="2fb64-264">Bei Festlegung `DisconnectTimeout`, `KeepAlive` automatisch auf 1/3 des festgelegt die `DisconnectTimeout` Wert.</span><span class="sxs-lookup"><span data-stu-id="2fb64-264">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="2fb64-265">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="2fb64-265">KeepAlive</span></span>

<span data-ttu-id="2fb64-266">Diese Einstellung steht für die Zeitdauer vor dem Senden eines Keepalive-Pakets über eine Verbindung im Leerlauf gewartet.</span><span class="sxs-lookup"><span data-stu-id="2fb64-266">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="2fb64-267">Der Standardwert ist 10 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="2fb64-267">The default value is 10 seconds.</span></span> <span data-ttu-id="2fb64-268">Dieser Wert darf nicht mehr als 1/3 des sein der `DisconnectTimeout` Wert.</span><span class="sxs-lookup"><span data-stu-id="2fb64-268">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="2fb64-269">Wenn Sie beide Optionen festlegen möchten `DisconnectTimeout` und `KeepAlive`legen `KeepAlive` nach `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="2fb64-269">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="2fb64-270">Andernfalls Ihre `KeepAlive` Einstellung werden überschrieben Wenn `DisconnectTimeout` automatisch `KeepAlive` 1/3 des Werts Timeout.</span><span class="sxs-lookup"><span data-stu-id="2fb64-270">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="2fb64-271">Wenn Sie Keepalive-Funktion deaktivieren möchten, legen Sie `KeepAlive` auf Null.</span><span class="sxs-lookup"><span data-stu-id="2fb64-271">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="2fb64-272">Keepalive-Funktionalität wird automatisch deaktiviert, für den langen abruftransport.</span><span class="sxs-lookup"><span data-stu-id="2fb64-272">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="2fb64-273">So ändern Sie die Einstellungen für Timeouts und "Keepalive"</span><span class="sxs-lookup"><span data-stu-id="2fb64-273">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="2fb64-274">Um die Standardwerte für diese Einstellungen zu ändern, legen Sie diese `Application_Start` in Ihrer *"Global.asax"* Datei, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="2fb64-274">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="2fb64-275">Die Werte, die im Beispielcode gezeigt sind identisch mit den Standardwerten.</span><span class="sxs-lookup"><span data-stu-id="2fb64-275">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="2fb64-276">Gewusst wie: Benachrichtigung des Benutzers zu trennen</span><span class="sxs-lookup"><span data-stu-id="2fb64-276">How to notify the user about disconnections</span></span>

<span data-ttu-id="2fb64-277">In einigen Anwendungen empfiehlt es sich um eine Nachricht an den Benutzer angezeigt wird, wenn Verbindungsprobleme vorliegen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-277">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="2fb64-278">Sie haben verschiedene Optionen, wie und wann dies erfolgen.</span><span class="sxs-lookup"><span data-stu-id="2fb64-278">You have several options for how and when to do this.</span></span> <span data-ttu-id="2fb64-279">Die folgenden Codebeispiele sind für einen JavaScript-Client mit den generierten Proxy.</span><span class="sxs-lookup"><span data-stu-id="2fb64-279">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="2fb64-280">Behandeln der `connectionSlow` Ereignis, um eine Meldung angezeigt, sobald SignalR bewusst behoben werden, ist bevor es in Verbindung Modus wechselt.</span><span class="sxs-lookup"><span data-stu-id="2fb64-280">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="2fb64-281">Behandeln der `reconnecting` Ereignis, um eine Meldung angezeigt wird, wenn SignalR eine Trennung beachten ist und wird in Verbindung Modus.</span><span class="sxs-lookup"><span data-stu-id="2fb64-281">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="2fb64-282">Behandeln der `disconnected` Timeout Ereignis zum Anzeigen einer Meldung, die bei einem fehlgeschlagenen Versuch, eine Verbindung herzustellen. In diesem Szenario ist die einzige Möglichkeit, eine Verbindung mit dem Server wiederherstellen, die einen Neustart der SignalR-Verbindung durch Aufrufen der `Start` -Methode, die erstellen eine neuen Verbindungs-ID.</span><span class="sxs-lookup"><span data-stu-id="2fb64-282">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="2fb64-283">Im folgenden Codebeispiel wird mit einem Flag um sicherzustellen, dass Sie die Benachrichtigung nur nach einem Timeout führt erneut eine Verbindung herstellt, nicht nach einem normalen End für die SignalR-Verbindung durch einen Aufruf verursacht ausgeben der `Stop` Methode.</span><span class="sxs-lookup"><span data-stu-id="2fb64-283">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="2fb64-284">Wiederherstellen der Verbindung fortlaufend</span><span class="sxs-lookup"><span data-stu-id="2fb64-284">How to continuously reconnect</span></span>

<span data-ttu-id="2fb64-285">In einigen Anwendungen empfiehlt es sich um automatisch eine Verbindung erneut herstellen, nachdem verloren gegangen ist und des Versuch, eine Verbindung herzustellen Timeout. Zu diesem Zweck rufen Sie die `Start` Methode aus Ihrer `Closed` Ereignishandler (`disconnected` Ereignishandler auf JavaScript-Clients).</span><span class="sxs-lookup"><span data-stu-id="2fb64-285">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="2fb64-286">Möglicherweise möchten Sie einen Zeitraum vor dem Aufruf warten `Start` , um zu vermeiden, dies zu häufig bei der Server oder die physische Verbindung sind nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="2fb64-286">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="2fb64-287">Im folgenden Codebeispiel ist ein JavaScript-Client mit den generierten Proxy.</span><span class="sxs-lookup"><span data-stu-id="2fb64-287">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="2fb64-288">Ein mögliches Problem in mobilen Clients berücksichtigen ist, dass fortlaufende erneuten Herstellen einer Verbindung versucht, wenn der Server oder die physische Verbindung verfügbar ist, unnötige Akku Ausgleichsmodus verursachen könnte.</span><span class="sxs-lookup"><span data-stu-id="2fb64-288">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="2fb64-289">Einen Client im Servercode Trennen der Verbindung</span><span class="sxs-lookup"><span data-stu-id="2fb64-289">How to disconnect a client in server code</span></span>

<span data-ttu-id="2fb64-290">Einen integrierte Server-API für die Trennung der Clientverbindungen keinen SignalR Version 2.</span><span class="sxs-lookup"><span data-stu-id="2fb64-290">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="2fb64-291">Es gibt [Pläne für das Hinzufügen dieser Funktionalität in der Zukunft](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="2fb64-291">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="2fb64-292">Die einfachste Methode zum Trennen von eines Clients vom Server werden in der aktuellen SignalR-Version aus eine Disconnect-Methode auf dem Client implementieren und Aufrufen dieser Methode vom Server.</span><span class="sxs-lookup"><span data-stu-id="2fb64-292">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="2fb64-293">Das folgende Codebeispiel zeigt eine Disconnect-Methode für einen JavaScript-Client mit den generierten Proxy.</span><span class="sxs-lookup"><span data-stu-id="2fb64-293">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="2fb64-294">Sicherheit – weder diese Methode zum Trennen der Clientverbindungen noch die vorgeschlagene integrierte API geht es um das Szenario der gehackten Clients, die bösartigen Code ausgeführt werden, da die Clients erneut Verbindungen hergestellt konnte oder der gehackte Code möglicherweise entfernt die `stopClient` -Methode, oder ändern welche Aktion er ausführt.</span><span class="sxs-lookup"><span data-stu-id="2fb64-294">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="2fb64-295">Die entsprechende Stelle um statusbehafteten Denial-of-Service (DOS)-Schutz zu implementieren ist nicht in das Framework oder der Server-Ebene, sondern im Front-End-Infrastruktur.</span><span class="sxs-lookup"><span data-stu-id="2fb64-295">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>


<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="2fb64-296">Ermitteln Sie den Grund für eine Trennung von</span><span class="sxs-lookup"><span data-stu-id="2fb64-296">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="2fb64-297">SignalR 2.1 fügt eine Überladung mit dem Server `OnDisconnect` Ereignis, das angibt, ob der Client absichtlich getrennt, anstatt ein Timeout auftritt. Die `StopCalled` Parameter ist "true", wenn der Client die Verbindung explizit geschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="2fb64-297">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="2fb64-298">In JavaScript, wenn ein Serverfehler den Client zu trennen, führte die Fehlerinformationen wird übergeben werden an den Client als `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="2fb64-298">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="2fb64-299">**C#-Servercode: `stopCalled` Parameter**</span><span class="sxs-lookup"><span data-stu-id="2fb64-299">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="2fb64-300">**JavaScript-Clientcode: Zugreifen auf `lastError` in die `disconnect` Ereignis.**</span><span class="sxs-lookup"><span data-stu-id="2fb64-300">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
