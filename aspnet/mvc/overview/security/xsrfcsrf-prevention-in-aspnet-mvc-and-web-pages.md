---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: XSRF/vom CSRF-Schutz in ASP.NET MVC und Web Pages | Microsoft Docs
author: Rick-Anderson
description: "Websiteübergreifende anforderungsfälschung (auch bekannt als XSRF oder FORGERY) ist ein Angriff gegen Web gehostete Anwendungen, bei dem eine bösartige Website die Interakti beeinflussen können..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/14/2013
ms.topic: article
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 4ff4ed20d0768a48f8afb2deeb7cdb6b4c60b5bc
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/10/2017
---
<a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="02fb1-103">XSRF/vom CSRF-Schutz in ASP.NET MVC und Web Pages</span><span class="sxs-lookup"><span data-stu-id="02fb1-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>
====================
<span data-ttu-id="02fb1-104">Durch [Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="02fb1-104">by [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

> <span data-ttu-id="02fb1-105">Cross-Site-Anforderung, dass (auch bekannt als XSRF oder FORGERY) auf einen Angriff auf Web gehostete Anwendungen ist bei dem eine bösartige Website für die Interaktion zwischen einem Clientbrowser und eine Website, die von diesen Browser als vertrauenswürdig eingestuft beeinflussen können.</span><span class="sxs-lookup"><span data-stu-id="02fb1-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="02fb1-106">Diese Angriffe sind möglich, da Webbrowsern Authentifizierungstoken automatisch mit jeder Anforderung an eine Website gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="02fb1-107">Kanonisches Beispiel ist ein Authentifizierungscookie, z. B. ASP. NET Forms-Authentifizierungsticket.</span><span class="sxs-lookup"><span data-stu-id="02fb1-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="02fb1-108">Websites, die alle persistenten Authentifizierungsmechanismus (z. B. Windows-Authentifizierung, Basic, usw.) verwenden können jedoch durch diese Angriffe angesprochen werden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="02fb1-109">Ein XSRF-Angriffen unterscheidet sich von einem Phishing-Attacke.</span><span class="sxs-lookup"><span data-stu-id="02fb1-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="02fb1-110">Phishing-Angriffe erfordern Eingreifen durch das Opfer.</span><span class="sxs-lookup"><span data-stu-id="02fb1-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="02fb1-111">In einer Phishing-Attacke eine bösartige Website wird die Zielwebsite imitieren und das Opfer erkennen Sie vertraulichen Informationen an den Angreifer bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="02fb1-112">Bei einem Angriff XSRF erfolgt häufig keine Interaktion erforderlich ist, über das Opfer.</span><span class="sxs-lookup"><span data-stu-id="02fb1-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="02fb1-113">Stattdessen wird der Angreifer auf den Browser senden alle relevanten Cookies automatisch an den Zielstandort für die Web Vertrauensstellungen der vertrauenden Seite.</span><span class="sxs-lookup"><span data-stu-id="02fb1-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="02fb1-114">Weitere Informationen finden Sie unter der [öffnen Webanwendungsprojekt Sicherheit](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span><span class="sxs-lookup"><span data-stu-id="02fb1-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>


## <a name="anatomy-of-an-attack"></a><span data-ttu-id="02fb1-115">Anatomie eines Angriffs</span><span class="sxs-lookup"><span data-stu-id="02fb1-115">Anatomy of an attack</span></span>

<span data-ttu-id="02fb1-116">Um eine XSRF-Angriffen zu durchlaufen, sollten Sie in ein Benutzer, einige Onlinebankingtransaktionen ausführen möchte.</span><span class="sxs-lookup"><span data-stu-id="02fb1-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="02fb1-117">Dieser Benutzer besucht zuerst WoodgroveBank.com und Protokolle, an welchem, die Punkt der Antwortheader ihr Authentifizierungscookie enthalten wird:</span><span class="sxs-lookup"><span data-stu-id="02fb1-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="02fb1-118">Da das Authentifizierungscookie ein Sitzungscookie ist, wird es vom Browser automatisch zurückgesetzt, wenn der Browserprozess beendet wird.</span><span class="sxs-lookup"><span data-stu-id="02fb1-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="02fb1-119">Allerdings wird der Browser bis zu diesem Zeitpunkt wird automatisch das Cookie mit jeder Anforderung zum WoodgroveBank.com enthalten. Der Benutzer möchte nun $1000 an ein anderes Konto übertragen werden, so dass sie ein Formular auf der Website Banking ausfüllt, und der Browser diese Anforderung an dem Server sendet:</span><span class="sxs-lookup"><span data-stu-id="02fb1-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com. The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="02fb1-120">Da dieser Vorgang einen Nebeneffekt hat (es initiiert eine finanzielle Transaktion), hat die Banking-Website ausgewählt, HTTP POST erforderlich ist, um diesen Vorgang zu initiieren.</span><span class="sxs-lookup"><span data-stu-id="02fb1-120">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="02fb1-121">Der Server liest das Authentifizierungstoken aus der Anforderung, sucht der Kontonummer des aktuellen Benutzers, stellt sicher, dass Deckung vorhanden sind, und klicken Sie dann die Transaktion in das Zielkonto initiiert.</span><span class="sxs-lookup"><span data-stu-id="02fb1-121">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="02fb1-122">Ihr Onlinebanking abgeschlossen, der Benutzer navigiert Weg von der Website Banking und Besuche von anderen Speicherorten im Web.</span><span class="sxs-lookup"><span data-stu-id="02fb1-122">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="02fb1-123">Einer dieser Websites – "fabrikam.com" – enthält das folgende Markup auf einer Seite eingebettet ein &lt;Iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="02fb1-123">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="02fb1-124">Die wiederum führt dazu, dass den Browser für diese Anforderung:</span><span class="sxs-lookup"><span data-stu-id="02fb1-124">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="02fb1-125">Der Angreifer missbraucht die Tatsache, dass der Benutzer möglicherweise ein gültiges Authentifizierungstoken für die Ziel-Website noch, und sie einen kleinen Ausschnitt von Javascript verwendet wird, um die dazu führen, dass den Browser HTTP POST an den Zielstandort automatisch.</span><span class="sxs-lookup"><span data-stu-id="02fb1-125">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="02fb1-126">Wenn das Authentifizierungstoken noch gültig ist, wird die Banking-Website eine Übertragung der 250 US-Dollar berücksichtigt der Angreifer Wahl initiiert.</span><span class="sxs-lookup"><span data-stu-id="02fb1-126">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="02fb1-127">Ineffektiven Maßnahmen</span><span class="sxs-lookup"><span data-stu-id="02fb1-127">Ineffective mitigations</span></span>

<span data-ttu-id="02fb1-128">Es ist interessant, beachten, dass im obigen Szenario ist die Tatsache, dass WoodgroveBank.com wurde über SSL zugegriffen, und es ein Cookie für die Authentifizierung nur über SSL wurde nicht ausreichend, um das Risiko eines Angriffs vereiteln wurde.</span><span class="sxs-lookup"><span data-stu-id="02fb1-128">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="02fb1-129">Der Angreifer kann an die [URI-Schema](http://en.wikipedia.org/wiki/URI_scheme) (Https) in ihrem &lt;Formular&gt; Element und den Browser nicht abgelaufenen Cookies an den Zielstandort gesendet werden, solange diese Cookies konsistent mit dem URI sind weiterhin das vorgesehene Ziel-Schema.</span><span class="sxs-lookup"><span data-stu-id="02fb1-129">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="02fb1-130">Eine könnte argumentieren, dass der Benutzer nicht besuchen Sie einfach sollte nicht vertrauenswürdigen Sites besuchen nur vertrauenswürdigen Sites ist, hilft Ihnen bei der sicheren online bleiben.</span><span class="sxs-lookup"><span data-stu-id="02fb1-130">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="02fb1-131">Es gibt einige Wahrheit dieser allerdings leider diesen Rat ist nicht immer praktisch.</span><span class="sxs-lookup"><span data-stu-id="02fb1-131">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="02fb1-132">Vielleicht vertraut"der Benutzer" die Website für lokale Nachrichten ConsolidatedMessenger.</span><span class="sxs-lookup"><span data-stu-id="02fb1-132">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="02fb1-133">ConsolidatedMessenger.com und kopiert wird, die stattdessen site besuchen, aber dieser Standort verfügt über eine XSS-Schwachstelle, wodurch Angreifern, den gleichen Codeausschnitt einzufügen, die auf "fabrikam.com" ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="02fb1-133">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="02fb1-134">Sie können sicherstellen, dass eingehende Anforderungen eine [referenzheader](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) verweisen auf Ihrer Domäne.</span><span class="sxs-lookup"><span data-stu-id="02fb1-134">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="02fb1-135">Dies wird von einer Drittanbieter-Domäne unwissentlich übermittelte Anforderungen beendet.</span><span class="sxs-lookup"><span data-stu-id="02fb1-135">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="02fb1-136">Allerdings einige Personen Deaktivieren des Browsers Referer-Header Gründen des Datenschutzes und Angreifer können manchmal diesen Header spoofen, wenn das Opfer bestimmte unsichere-Software installiert ist.</span><span class="sxs-lookup"><span data-stu-id="02fb1-136">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="02fb1-137">Überprüfen der [referenzheader](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) einen sicheren Ansatz für die Verhinderung von XSRF-Angriffen wird nicht berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="02fb1-137">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="02fb1-138">Web Stapel Runtime XSRF Maßnahmen</span><span class="sxs-lookup"><span data-stu-id="02fb1-138">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="02fb1-139">Der ASP.NET Web-Stack-Runtime verwendet eine Variante der [für die domänensynchronisierung tokenmuster](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) Verteidigung gegen XSRF-Angriffen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-139">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="02fb1-140">Das allgemeine Format des Musters token für die domänensynchronisierung ist, dass zwei Anti-XSRF-Token mit jeder HTTP-POST (zusätzlich zum das Authentifizierungstoken) an den Server übermittelt werden: eine als ein Cookie, und der andere als ein Formularwert-Token.</span><span class="sxs-lookup"><span data-stu-id="02fb1-140">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="02fb1-141">Die Tokenwerte generiert, durch die ASP.NET-Laufzeit sind nicht deterministisch oder von einem Angreifer vorhersagbare.</span><span class="sxs-lookup"><span data-stu-id="02fb1-141">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="02fb1-142">Wenn das Token übermittelt werden, lässt der Server die Anforderung fortgesetzt werden, nur dann, wenn beide Token eine Vergleich die Überprüfung bestanden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-142">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="02fb1-143">Die Anforderung XSRF-Überprüfung *Sitzungstoken* wird als ein HTTP-Cookie gespeichert und derzeit die folgende Informationen in der Nutzlast enthält:</span><span class="sxs-lookup"><span data-stu-id="02fb1-143">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="02fb1-144">Ein Sicherheitstoken, bestehend aus einer zufälligen 128-Bit-Bezeichner.</span><span class="sxs-lookup"><span data-stu-id="02fb1-144">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="02fb1-145">Die folgende Abbildung zeigt das XSRF-Überprüfung Sitzung Anforderungstoken angezeigt, mit der Internet Explorer F12-Entwicklungstools: (Hinweis Dies ist die aktuelle Implementierung und Betreff "," sogar wahrscheinlich ändern.)</span><span class="sxs-lookup"><span data-stu-id="02fb1-145">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="02fb1-146">Die *Feldtoken* gespeichert ist, als ein `<input type="hidden" />` und enthält die folgenden Informationen in der Nutzlast:</span><span class="sxs-lookup"><span data-stu-id="02fb1-146">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="02fb1-147">Benutzername des angemeldeten Benutzers, (wenn nicht authentifiziert).</span><span class="sxs-lookup"><span data-stu-id="02fb1-147">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="02fb1-148">Alle zusätzlichen Daten, das durch ein [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span><span class="sxs-lookup"><span data-stu-id="02fb1-148">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="02fb1-149">Die Nutzlast der Anti-XSRF-Token werden verschlüsselt und signiert, damit Sie den Benutzernamen nicht anzeigen können, wenn Sie Tools verwenden, um die Token zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-149">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="02fb1-150">Wenn die Webanwendung ASP.NET 4.0 vorgesehen ist, werden von kryptografische Dienste bereitgestellt der [MachineKey.Encode](https://msdn.microsoft.com/en-us/library/system.web.security.machinekey.encode.aspx) Routine.</span><span class="sxs-lookup"><span data-stu-id="02fb1-150">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/en-us/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="02fb1-151">Wenn die Webanwendung vorgesehen ist ASP.NET 4.5 oder höher, kryptografische Dienste über bereitgestellt werden die [MachineKey.Protect](https://msdn.microsoft.com/en-us/library/system.web.security.machinekey.protect(v=vs.110)) -Routine, die eine bessere Leistung, Erweiterbarkeit und Sicherheit bietet.</span><span class="sxs-lookup"><span data-stu-id="02fb1-151">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/en-us/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="02fb1-152">Sehen Sie sich die folgenden Blogbeiträge Weitere Details:</span><span class="sxs-lookup"><span data-stu-id="02fb1-152">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="02fb1-153">Kryptografische Verbesserungen in ASP.NET 4.5, pt. 1</span><span class="sxs-lookup"><span data-stu-id="02fb1-153">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="02fb1-154">Kryptografische Verbesserungen in ASP.NET 4.5, pt. 2</span><span class="sxs-lookup"><span data-stu-id="02fb1-154">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="02fb1-155">Kryptografische Verbesserungen in ASP.NET 4.5, pt. 3</span><span class="sxs-lookup"><span data-stu-id="02fb1-155">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="02fb1-156">Generieren von Token</span><span class="sxs-lookup"><span data-stu-id="02fb1-156">Generating the tokens</span></span>

<span data-ttu-id="02fb1-157">Um die Anti-XSRF-Token zu generieren, rufen die [ @Html.AntiForgeryToken ](https://msdn.microsoft.com/en-us/library/dd470175.aspx) Methode aus einer MVC-Ansicht oder @AntiForgery.GetHtml() aus einer Razor-Seite.</span><span class="sxs-lookup"><span data-stu-id="02fb1-157">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/en-us/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="02fb1-158">Die Common Language Runtime führt dann die folgenden Schritte aus:</span><span class="sxs-lookup"><span data-stu-id="02fb1-158">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="02fb1-159">Wenn die aktuelle HTTP-Anforderung bereits eine Sitzung Anti-XSRF-Token enthält (das Cookie Anti-XSRF \_ \_RequestVerificationToken), das Sicherheitstoken wird daraus extrahiert.</span><span class="sxs-lookup"><span data-stu-id="02fb1-159">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="02fb1-160">Wenn die HTTP-Anforderung enthält kein Anti-XSRF-Token-Sitzung oder wenn Fehler bei der Extraktion des Sicherheitstokens, ein neues zufälliges Anti-XSRF-Token generiert werden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-160">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="02fb1-161">Ein Feld Anti-XSRF-Token wird mithilfe des Sicherheitstokens aus vorigen Schritt (1) und die Identität des aktuellen angemeldeten Benutzers generiert.</span><span class="sxs-lookup"><span data-stu-id="02fb1-161">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="02fb1-162">(Weitere Informationen zum Ermitteln der Benutzeridentität finden Sie unter der  **[Szenarien mit Unterstützung für spezielle](#_Scenarios_with_special)**  Abschnitt weiter unten.) Darüber hinaus Wenn ein [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/jj158328(v=vs.111).aspx) wird konfiguriert, die Common Language Runtime ruft seine [GetAdditionalData](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) Methode und die zurückgegebene Zeichenfolge im Feldtoken enthalten.</span><span class="sxs-lookup"><span data-stu-id="02fb1-162">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="02fb1-163">(Siehe die  **[Konfigurations- und Erweiterbarkeit](#_Configuration_and_extensibility)**  Abschnitt, um weitere Informationen.)</span><span class="sxs-lookup"><span data-stu-id="02fb1-163">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="02fb1-164">Neues Anti-XSRF-Token in Schritt (1) generiert wurde, wird ein Token für die neue Sitzung erstellt werden, enthalten und wird der ausgehenden HTTP-Cookies-Auflistung hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-164">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="02fb1-165">Wird das Feldtoken aus Schritt (2) umschlossen werden ein `<input type="hidden" />` -Element, und diese HTML-Markup wird der Rückgabewert der `Html.AntiForgeryToken()` oder `AntiForgery.GetHtml()`.</span><span class="sxs-lookup"><span data-stu-id="02fb1-165">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="02fb1-166">Überprüfen die Token</span><span class="sxs-lookup"><span data-stu-id="02fb1-166">Validating the tokens</span></span>

<span data-ttu-id="02fb1-167">Um die eingehenden Anti-XSRF-Token zu überprüfen, die Entwickler umfasst eine [ValidateAntiForgeryToken](https://msdn.microsoft.com/en-us/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) Attribut für ihre MVC-Aktion oder des Controllers oder She Aufrufe `@AntiForgery.Validate()` aus ihrem Razor-Seite.</span><span class="sxs-lookup"><span data-stu-id="02fb1-167">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/en-us/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="02fb1-168">Die Common Language Runtime führt die folgenden Schritte aus:</span><span class="sxs-lookup"><span data-stu-id="02fb1-168">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="02fb1-169">Die eingehende Sitzungstoken und das Feldtoken werden gelesen, und die Anti-XSRF-Token extrahiert aus jedem.</span><span class="sxs-lookup"><span data-stu-id="02fb1-169">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="02fb1-170">Die Anti-XSRF-Token müssen pro Schritt (2) in der Routine Generation identisch sein.</span><span class="sxs-lookup"><span data-stu-id="02fb1-170">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="02fb1-171">Wenn der aktuelle Benutzer authentifiziert ist, wird ihr Benutzername mit dem Benutzernamen in das Feldtoken gespeicherten verglichen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-171">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="02fb1-172">Die Benutzernamen übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-172">The usernames must match.</span></span>
3. <span data-ttu-id="02fb1-173">Wenn ein [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) konfiguriert ist, ruft die Laufzeit die *ValidateAdditionalData* Methode.</span><span class="sxs-lookup"><span data-stu-id="02fb1-173">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="02fb1-174">Die Methode muss den booleschen Wert zurückgeben *"true"*.</span><span class="sxs-lookup"><span data-stu-id="02fb1-174">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="02fb1-175">Bei erfolgreicher Überprüfung wird die Anforderung zugelassen, um den Vorgang fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-175">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="02fb1-176">Wenn die Validierung fehlschlägt, löst das Framework eine *HttpAntiForgeryException*.</span><span class="sxs-lookup"><span data-stu-id="02fb1-176">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="02fb1-177">Fehlerbedingungen</span><span class="sxs-lookup"><span data-stu-id="02fb1-177">Failure conditions</span></span>

<span data-ttu-id="02fb1-178">Beginnend mit der ASP.NET Web-Stapel Runtime v2, alle *HttpAntiForgeryException* ausgelöst, die während der Validierung enthält ausführliche Informationen zu den Einzelheiten.</span><span class="sxs-lookup"><span data-stu-id="02fb1-178">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="02fb1-179">Die aktuell definierten fehlerbedingungen sind:</span><span class="sxs-lookup"><span data-stu-id="02fb1-179">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="02fb1-180">Das Sitzungstoken oder formulartokens ist nicht in der Anforderung vorhanden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-180">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="02fb1-181">Das Sitzungstoken oder formulartokens ist nicht lesbar.</span><span class="sxs-lookup"><span data-stu-id="02fb1-181">The session token or form token is unreadable.</span></span> <span data-ttu-id="02fb1-182">Die wahrscheinlichste Ursache ist eine nicht übereinstimmende Versionen der ASP.NET Web-Stapel Runtime oder eine Farm-Farm, in dem die &lt;MachineKey&gt; Element in der Datei "Web.config" unterscheidet sich zwischen Computern.</span><span class="sxs-lookup"><span data-stu-id="02fb1-182">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="02fb1-183">Sie können ein Tool wie Fiddler verwenden, diese Ausnahme zu erzwingen, indem Sie die Manipulation von entweder Anti-XSRF-Token.</span><span class="sxs-lookup"><span data-stu-id="02fb1-183">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="02fb1-184">Das Sitzungstoken und Feldtoken wurden ausgetauscht.</span><span class="sxs-lookup"><span data-stu-id="02fb1-184">The session token and field token were swapped.</span></span>
- <span data-ttu-id="02fb1-185">Das Sitzungstoken und Feldtoken enthalten, nicht übereinstimmende Sicherheitstoken.</span><span class="sxs-lookup"><span data-stu-id="02fb1-185">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="02fb1-186">Der Benutzername, der in das Feldtoken eingebettet entspricht nicht den angemeldeten Benutzernamen des aktuellen Benutzers.</span><span class="sxs-lookup"><span data-stu-id="02fb1-186">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="02fb1-187">Die  *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)*  zurückgegebene Methode *"false"*.</span><span class="sxs-lookup"><span data-stu-id="02fb1-187">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="02fb1-188">Die Anti-XSRF-Funktionen möglicherweise auch zusätzliche wird die Überprüfung während der Generierung von Tokens oder Überprüfung durchgeführt, und Fehler während dieser Tests möglicherweise ausgelösten Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-188">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="02fb1-189">Finden Sie unter der [WIF / ACS / anspruchsbasierte Authentifizierung](#_WIF_ACS) und  **[Konfigurations- und Erweiterbarkeit](#_Configuration_and_extensibility)**  Abschnitten Weitere Informationen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-189">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="02fb1-190">Szenarien mit spezielle Unterstützung</span><span class="sxs-lookup"><span data-stu-id="02fb1-190">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="02fb1-191">Anonyme Authentifizierung</span><span class="sxs-lookup"><span data-stu-id="02fb1-191">Anonymous authentication</span></span>

<span data-ttu-id="02fb1-192">Die Anti-XSRF-System enthält spezielle Unterstützung für anonyme Benutzer, wobei "Anonym" als ein Benutzer definiert ist, in dem die *IIdentity.IsAuthenticated* -Eigenschaft gibt *"false"*.</span><span class="sxs-lookup"><span data-stu-id="02fb1-192">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="02fb1-193">Szenarien zum Schutz der Anmeldeseite (bevor der Benutzer authentifiziert wurde) und benutzerdefinierte Authentifizierungsschemas, bei denen die Anwendung einen Mechanismus außer verwendet, XSRF *"IIdentity" wird* zur Identifizierung von Benutzern.</span><span class="sxs-lookup"><span data-stu-id="02fb1-193">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="02fb1-194">Um diese Szenarien zu unterstützen, denken Sie daran, dass die Sitzung und Feld-Token durch ein Sicherheitstoken verknüpft sind, also eine 128-Bit-zufällig generierte nicht transparenter Bezeichner.</span><span class="sxs-lookup"><span data-stu-id="02fb1-194">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="02fb1-195">Dieses Sicherheitstoken wird verwendet, um eine einzelne benutzersitzung nachzuverfolgen, wie sie den Standort so effektiv den Zweck eines anonymen Bezeichners dient navigiert.</span><span class="sxs-lookup"><span data-stu-id="02fb1-195">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="02fb1-196">Eine leere Zeichenfolge ist für die Generierung und Überprüfung Routinen, die oben beschriebenen anstelle des Benutzernamens verwendet.</span><span class="sxs-lookup"><span data-stu-id="02fb1-196">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="02fb1-197">WIF / ACS / anspruchsbasierter Authentifizierung</span><span class="sxs-lookup"><span data-stu-id="02fb1-197">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="02fb1-198">In der Regel wird die *"IIdentity" wird* Klassen, die in .NET Framework integriert haben, die Eigenschaft, die *IIdentity.Name* ist ausreichend, um einen bestimmten Benutzer innerhalb einer bestimmten Anwendung eindeutig identifizieren.</span><span class="sxs-lookup"><span data-stu-id="02fb1-198">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="02fb1-199">Beispielsweise *FormsIdentity.Name* gibt den Benutzernamen, die in der Mitgliedschaftsdatenbank (die für alle Anwendungen, abhängig von der Datenbank eindeutig ist), gespeicherte *WindowsIdentity.Name* gibt die domänenqualifizierte Identität des Benutzers, und So weiter.</span><span class="sxs-lookup"><span data-stu-id="02fb1-199">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="02fb1-200">Diese Systeme bieten nicht nur die Authentifizierung; Sie auch *identifizieren* Benutzer zu einer Anwendung.</span><span class="sxs-lookup"><span data-stu-id="02fb1-200">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="02fb1-201">Anspruchsbasierte Authentifizierung auf der anderen Seite erfordert nicht unbedingt einen bestimmten Benutzer zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="02fb1-201">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="02fb1-202">Stattdessen die *ClaimsPrincipal* und *"ClaimsIdentity"* Typen werden mit einem Satz von zugeordneten *Anspruch* Instanzen, in denen die einzelnen Ansprüche möglicherweise "über 18 Jahre alt ist" oder " ist ein Administrator"zu einem anderen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-202">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="02fb1-203">Da der Benutzer noch nicht notwendigerweise identifiziert wurde, kann die Common Language Runtime nicht verwenden die *ClaimsIdentity.Name* Eigenschaft als eindeutiger Bezeichner für diesen bestimmten Benutzer.</span><span class="sxs-lookup"><span data-stu-id="02fb1-203">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="02fb1-204">Das Team kann angezeigt werden, praktische Beispiele, in denen *ClaimsIdentity.Name* gibt *null*zurückgegeben einen angezeigten Namen, oder andernfalls gibt eine Zeichenfolge, die nicht für die Verwendung als eindeutiger Bezeichner geeignet ist für den Benutzer.</span><span class="sxs-lookup"><span data-stu-id="02fb1-204">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="02fb1-205">Viele Bereitstellungen, die anspruchsbasierte Authentifizierung verwendet verwenden [Azure Access Control Service](https://msdn.microsoft.com/en-us/library/windowsazure/gg429786.aspx) (ACS) insbesondere.</span><span class="sxs-lookup"><span data-stu-id="02fb1-205">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/en-us/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="02fb1-206">ACS ermöglicht es dem Entwickler so konfigurieren Sie einzelne *Identitätsanbieter* (z. B. AD FS, die Microsoft-Account-Anbieter, OpenID-Anbietern wie Yahoo! usw.), und geben Sie die Identitätsanbieter zurück *Benennen von Bezeichnern*.</span><span class="sxs-lookup"><span data-stu-id="02fb1-206">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="02fb1-207">Diese Namen Bezeichner können Daten mit persönlich identifizierbaren Informationen (PII) enthalten, wie eine e-Mail-Adresse, oder sie können z. B. einen privaten persönlichen Bezeichner (PPID) anonymisiert.</span><span class="sxs-lookup"><span data-stu-id="02fb1-207">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="02fb1-208">Unabhängig davon, das Tupel (Identitätsanbieter, Namensbezeichner) ausreichend dient als entsprechende Überwachungsprofil Token für einen bestimmten Benutzer, während sie die Website durchsucht, damit der ASP.NET Web-Stapel Runtime Tupel anstelle von Benutzernamen verwenden können, während der Generierung und Überprüfen die Anti-XSRF-Feld-Token.</span><span class="sxs-lookup"><span data-stu-id="02fb1-208">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="02fb1-209">Die bestimmte URIs für den Identitätsanbieter und der Namensbezeichner sind:</span><span class="sxs-lookup"><span data-stu-id="02fb1-209">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="02fb1-210">(finden Sie in diesem [ACS Doc Seite](https://msdn.microsoft.com/en-us/library/windowsazure/gg185971.aspx) für Weitere Informationen.)</span><span class="sxs-lookup"><span data-stu-id="02fb1-210">(see this [ACS doc page](https://msdn.microsoft.com/en-us/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="02fb1-211">Beim Generieren oder Überprüfen eines Tokens, wird der ASP.NET Web-Stapel Runtime Bindung zu den Typen zur Laufzeit versucht:</span><span class="sxs-lookup"><span data-stu-id="02fb1-211">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="02fb1-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35`(Für die WIF-SDK).</span><span class="sxs-lookup"><span data-stu-id="02fb1-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="02fb1-213">`System.Security.Claims.ClaimsIdentity`(Für .NET 4.5).</span><span class="sxs-lookup"><span data-stu-id="02fb1-213">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="02fb1-214">Wenn diese Typen vorhanden sind, und wenn des aktuellen Benutzers *IIIIdentity* implementiert oder Unterklassen eines der folgenden Typen ist, wird die Anti-XSRF-Funktion (Identitätsanbieter, Namensbezeichner) Tupel anstelle der Benutzername beim Generieren und Überprüfen die Token an.</span><span class="sxs-lookup"><span data-stu-id="02fb1-214">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="02fb1-215">Wenn keine solche Tupel vorhanden ist, schlägt die Anforderung mit einem Fehler beschrieben, die Entwickler zum Konfigurieren des Anti-XSRF-Systems, um zu verstehen, den bestimmten anspruchsbasierte Authentifizierungsmechanismus verwendet fehl.</span><span class="sxs-lookup"><span data-stu-id="02fb1-215">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="02fb1-216">Finden Sie unter der  **[Konfigurations- und Erweiterbarkeit](#_Configuration_and_extensibility)**  Abschnitt, um weitere Informationen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-216">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="02fb1-217">OAuth / OpenID-Authentifizierung</span><span class="sxs-lookup"><span data-stu-id="02fb1-217">OAuth / OpenID authentication</span></span>

<span data-ttu-id="02fb1-218">Schließlich verfügt die Anti-XSRF-Funktion spezielle Unterstützung für Anwendungen, die OAuth- oder OpenID-Authentifizierung verwenden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-218">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="02fb1-219">Diese Unterstützung basiert auf Heuristik: Wenn die aktuelle *IIdentity.Name* beginnt mit http:// oder https://, dann Benutzernamen Vergleiche erfolgen, werden der OrdinalIgnoreCase Standardvergleich, statt einen ordinalen Vergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-219">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="02fb1-220">Konfiguration und Erweiterbarkeit</span><span class="sxs-lookup"><span data-stu-id="02fb1-220">Configuration and extensibility</span></span>

<span data-ttu-id="02fb1-221">In einigen Fällen möchten Entwickler eine strengere Kontrolle über die Anti-XSRF-Generierung und Überprüfung Verhalten.</span><span class="sxs-lookup"><span data-stu-id="02fb1-221">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="02fb1-222">Z. B. Hilfsprogramme MVC und Web Pages-Standardverhalten automatisch zum Hinzufügen von HTTP-Cookies, in die Antwort ist möglicherweise nicht wünschenswert, und der Entwickler die Token an anderer Stelle beibehalten möchten.</span><span class="sxs-lookup"><span data-stu-id="02fb1-222">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="02fb1-223">Es gibt noch zwei APIs, die dabei helfen:</span><span class="sxs-lookup"><span data-stu-id="02fb1-223">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="02fb1-224">Die *GetTokens* Methode nimmt als Eingabe eine vorhandenen XSRF-Überprüfung Sitzung Anforderungstoken (die null sein kann) und erzeugt als Ausgabe eine neue XSRF-Überprüfung Sitzung Anforderungstoken und Feldtoken.</span><span class="sxs-lookup"><span data-stu-id="02fb1-224">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="02fb1-225">Die Token sind einfach opake Zeichenfolgen ohne Dekoration; die *FormToken* Wert wird für die Instanz nicht umschlossen werden ein &lt;input&gt; Tag.</span><span class="sxs-lookup"><span data-stu-id="02fb1-225">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="02fb1-226">Die *NewCookieToken* Wert ist möglicherweise null; in diesem Fall wird das *OldCookieToken* Wert ist immer noch gültig und muss kein neues Antwortcookie festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-226">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="02fb1-227">Der Aufrufer *GetTokens* ist verantwortlich für alle erforderlichen Antwort Cookies beibehalten oder Generieren von Markup erforderlich; die *GetTokens* Methode selbst ändert sich nicht auf die Antwort als einen Nebeneffekt auslösen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-227">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="02fb1-228">Die *Validate* Methode akzeptiert die eingehende Sitzung und Feld-Token und die zuvor erwähnten Validierungslogik durchläuft.</span><span class="sxs-lookup"><span data-stu-id="02fb1-228">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="02fb1-229">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="02fb1-229">AntiForgeryConfig</span></span>

<span data-ttu-id="02fb1-230">Der Entwickler kann die Anti-XSRF-System aus Anwendung konfigurieren\_starten.</span><span class="sxs-lookup"><span data-stu-id="02fb1-230">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="02fb1-231">Programmgesteuerte ist konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="02fb1-231">Configuration is programmatic.</span></span> <span data-ttu-id="02fb1-232">Die Eigenschaften des statischen *AntiForgeryConfig* Typ im folgenden beschrieben.</span><span class="sxs-lookup"><span data-stu-id="02fb1-232">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="02fb1-233">Die meisten Benutzer mit Ansprüchen sollten die UniqueClaimTypeIdentifier-Eigenschaft festgelegt.</span><span class="sxs-lookup"><span data-stu-id="02fb1-233">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="02fb1-234">**Property**</span><span class="sxs-lookup"><span data-stu-id="02fb1-234">**Property**</span></span> | <span data-ttu-id="02fb1-235">**Beschreibung**</span><span class="sxs-lookup"><span data-stu-id="02fb1-235">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="02fb1-236">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="02fb1-236">**AdditionalDataProvider**</span></span> | <span data-ttu-id="02fb1-237">Ein [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , die zusätzliche Daten während der Generierung von Tokens bereitstellt und verwendet zusätzliche Daten während der Überprüfung von token.</span><span class="sxs-lookup"><span data-stu-id="02fb1-237">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="02fb1-238">Der Standardwert ist *null*.</span><span class="sxs-lookup"><span data-stu-id="02fb1-238">The default value is *null*.</span></span> <span data-ttu-id="02fb1-239">Weitere Informationen finden Sie unter der [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="02fb1-239">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="02fb1-240">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="02fb1-240">**CookieName**</span></span> | <span data-ttu-id="02fb1-241">Eine Zeichenfolge, die den Namen des HTTP-Cookies bereitstellt, die zum Speichern der Sitzung Anti-XSRF-Token verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="02fb1-241">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="02fb1-242">Wenn dieser Wert nicht festgelegt ist, wird ein Name automatisch basierend auf der Anwendung bereitgestellten virtuellen Pfad generiert werden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-242">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="02fb1-243">Der Standardwert ist *null*.</span><span class="sxs-lookup"><span data-stu-id="02fb1-243">The default value is *null*.</span></span> |
| <span data-ttu-id="02fb1-244">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="02fb1-244">**RequireSsl**</span></span> | <span data-ttu-id="02fb1-245">Ein boolescher Wert, der bestimmt, ob die Anti-XSRF-Token über einen SSL-gesicherte Kanal gesendet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-245">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="02fb1-246">Wenn dieser Wert ist *"true"*Cookies automatisch generiert werden das "secure"-Flag festgelegt haben und die Anti-XSRF-APIs wird ausgelöst, wenn in einer Anforderung aufgerufen, die nicht über SSL übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="02fb1-246">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="02fb1-247">Der Standardwert ist *FALSE*.</span><span class="sxs-lookup"><span data-stu-id="02fb1-247">The default value is *false*.</span></span> |
| <span data-ttu-id="02fb1-248">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="02fb1-248">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="02fb1-249">Ein boolescher Wert, der bestimmt, ob die Anti-XSRF-System die Unterstützung für anspruchsbasierte Identitäten deaktiviert werden soll.</span><span class="sxs-lookup"><span data-stu-id="02fb1-249">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="02fb1-250">Wenn dieser Wert ist *"true"*, wird das System davon ausgehen, dass *IIdentity.Name* eignet sich für die Verwendung als eine eindeutige pro-Benutzer-ID und versucht nicht, spezielle *IClaimsIdentity*oder *ClClaimsIdentity* wie beschrieben in der [WIF / ACS / anspruchsbasierte Authentifizierung](#_WIF_ACS) Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="02fb1-250">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="02fb1-251">Der Standardwert ist `false`.</span><span class="sxs-lookup"><span data-stu-id="02fb1-251">The default value is `false`.</span></span> |
| <span data-ttu-id="02fb1-252">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="02fb1-252">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="02fb1-253">Eine Zeichenfolge, die angibt, welcher Anspruchstyp eignet sich für die Verwendung als eine eindeutige pro-Benutzer-ID.</span><span class="sxs-lookup"><span data-stu-id="02fb1-253">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="02fb1-254">Wenn dieser Wert festlegen und die aktuelle *"IIdentity" wird* angegebenen anspruchsbasierte, das System versucht, einen Anspruch des Typs extrahieren *UniqueClaimTypeIdentifier*, und der entsprechende Wert verwendet werden anstelle der Benutzername des Benutzers während der Generierung der Feld-Token.</span><span class="sxs-lookup"><span data-stu-id="02fb1-254">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="02fb1-255">Wenn der Typ des Anspruchs nicht gefunden wird, wird das System die Anforderung fehl.</span><span class="sxs-lookup"><span data-stu-id="02fb1-255">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="02fb1-256">Der Standardwert ist *null*, was bedeutet, dass das System verwenden soll, die (Identitätsanbieter, Namensbezeichner) Tupel anstelle der Benutzername des Benutzers wie zuvor beschrieben.</span><span class="sxs-lookup"><span data-stu-id="02fb1-256">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="02fb1-257">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="02fb1-257">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="02fb1-258">Die  *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)*  Typ ermöglicht Entwicklern das Verhalten des Anti-XSRF-Systems durch zusätzliche Round-Tripping-Daten in einzelnen Token zu erweitern.</span><span class="sxs-lookup"><span data-stu-id="02fb1-258">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="02fb1-259">Die *GetAdditionalData* Methode wird jedes Mal aufgerufen, wenn ein Token wird generiert, und der Rückgabewert in das generierte Token eingebettet ist.</span><span class="sxs-lookup"><span data-stu-id="02fb1-259">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="02fb1-260">Eine Implementierung konnte einen Zeitstempel, eine Nonce oder einen anderen Wert, den er möchte von dieser Methode zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="02fb1-260">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="02fb1-261">Auf ähnliche Weise die *ValidateAdditionalData* Methode wird jedes Mal aufgerufen, wenn ein Token überprüft wird und die "zusätzliche Daten"-Zeichenfolge, die das Token eingebettet wurde an die Methode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="02fb1-261">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="02fb1-262">Die Validierungsroutine kann einen Timeout (durch überprüfen die aktuelle Zeit mit dem Zeitpunkt, die gespeichert wurde, wenn das Token erstellt wurde) implementieren, eine Nonce überprüfen, Routine oder ein anderes gewünscht Logik.</span><span class="sxs-lookup"><span data-stu-id="02fb1-262">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="02fb1-263">Entwurfsentscheidungen und Überlegungen zur Sicherheit</span><span class="sxs-lookup"><span data-stu-id="02fb1-263">Design decisions and security considerations</span></span>

<span data-ttu-id="02fb1-264">Das Sicherheitstoken, das verknüpft und die Sitzung und Feld-Token ist technisch nur erforderlich, beim Versuch, eine anonyme / nicht authentifizierte Benutzer vor XSRF-Angriffen schützen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-264">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="02fb1-265">Wenn der Benutzer authentifiziert ist, konnte das Authentifizierungstoken selbst (vermutlich in Form eines Cookies übermittelt) verwendet werden, als die Hälfte der einer für die domänensynchronisierung Tokenpaars.</span><span class="sxs-lookup"><span data-stu-id="02fb1-265">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="02fb1-266">Allerdings stehen gültige Szenarien für den Schutz von Anmeldeseiten, die durch nicht authentifizierte Benutzer erreicht, und die Anti-XSRF-Logik wurde durch immer generieren und überprüfen das Sicherheitstoken, dies gilt auch für authentifizierte Benutzer einfacher versucht.</span><span class="sxs-lookup"><span data-stu-id="02fb1-266">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="02fb1-267">Es stellt auch einige zusätzlichen Schutz bereit, wenn ein Token von einem Angreifer, als festlegen oder zu erraten, dass das Sitzungstoken wäre, einen anderen Hürde für Angreifer zu überwinden je kompromittiert ist.</span><span class="sxs-lookup"><span data-stu-id="02fb1-267">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="02fb1-268">Entwickler sollten Vorsicht verwenden, wenn mehrere Anwendungen in einer einzigen Domäne gehostet werden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-268">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="02fb1-269">Beispielsweise, obwohl *example1.cloudapp.net* und *example2.cloudapp.net* sind verschiedene Hosts besteht ein implizites Vertrauensverhältnis zwischen allen Hosts unter der  *\*. cloudapp.net* Domäne.</span><span class="sxs-lookup"><span data-stu-id="02fb1-269">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="02fb1-270">Diese implizite Vertrauensstellung [können potenziell nicht vertrauenswürdige Hosts Cookies gegenseitig beeinträchtigen](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (die gleichen-Origin-Richtlinien, die AJAX-Anforderungen steuern unbedingt gelten nicht für HTTP-Cookies).</span><span class="sxs-lookup"><span data-stu-id="02fb1-270">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="02fb1-271">Der ASP.NET Web-Stapel Runtime bietet einige Verringerung, der Benutzernamen in das Feldtoken eingebettet ist, selbst wenn eine böswillige Unterdomäne einen Sitzungstoken überschreiben kann zum Generieren eines gültigen Felds Tokens für den Benutzer werden.</span><span class="sxs-lookup"><span data-stu-id="02fb1-271">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="02fb1-272">Allerdings können nicht beim Hosten in einer derartigen Umgebung die integrierte Anti-XSRF-Routinen weiterhin Sitzungsübernahme oder Anmeldung XSRF Verteidigung gegen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-272">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="02fb1-273">Die Anti-XSRF-Routinen werden derzeit nicht für verteidigen [Clickjacking](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="02fb1-273">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="02fb1-274">Anwendungen, die selbst Verteidigung gegen Clickjacking möchten können dies ganz einfach durch eine X-Frame-Options senden: SAMEORIGIN-Header mit jeder Antwort.</span><span class="sxs-lookup"><span data-stu-id="02fb1-274">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="02fb1-275">Dieser Header wird von allen aktuellen Browsern unterstützt.</span><span class="sxs-lookup"><span data-stu-id="02fb1-275">This header is supported by all recent browsers.</span></span> <span data-ttu-id="02fb1-276">Weitere Informationen finden Sie unter der [IE-Blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), [SDL-Blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), und [OWASP](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="02fb1-276">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="02fb1-277">Die Web-Stapel ASP.NET-Laufzeit möglicherweise sind einige der nächsten Releases MVC und Webseiten Anti-XSRF-Hilfsprogrammen diese Header automatisch festgelegt, damit Anwendungen automatisch vor diesen Angriffen geschützt sind.</span><span class="sxs-lookup"><span data-stu-id="02fb1-277">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="02fb1-278">Entwickler von Websites sollte weiterhin stellen Sie sicher, dass die Website nicht XSS-Angriffe anfällig ist.</span><span class="sxs-lookup"><span data-stu-id="02fb1-278">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="02fb1-279">XSS-Angriffen sind sehr leistungsstark und einem erfolgreichen Angriff wird auch der ASP.NET Web-Stapel Runtime entsprechende Schutzmaßnahmen vor XSRF-Angriffen unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="02fb1-279">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="02fb1-280">Bestätigung</span><span class="sxs-lookup"><span data-stu-id="02fb1-280">Acknowledgment</span></span>

<span data-ttu-id="02fb1-281">[@LeviBroderick](https://twitter.com/LeviBroderick), ein Großteil der ASP.NET-Code für die Sicherheit den Großteil dieser Informationen geschrieben.</span><span class="sxs-lookup"><span data-stu-id="02fb1-281">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
