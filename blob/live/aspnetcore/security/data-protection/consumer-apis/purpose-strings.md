---
title: Zweck Zeichenfolgen
author: rick-anderson
description: "Dieses Dokument wird erläutert, wie Zeichenfolgen Zweck in der ASP.NET Core Datenschutz-APIs verwendet werden."
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/consumer-apis/purpose-strings
ms.openlocfilehash: b1e95c9d0aa8195aa73fddfb97a4079e67a351bf
ms.sourcegitcommit: 3e303620a125325bb9abd4b2d315c106fb8c47fd
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/19/2018
---
# <a name="purpose-strings"></a><span data-ttu-id="e7608-103">Zweck Zeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="e7608-103">Purpose Strings</span></span>

<a name="data-protection-consumer-apis-purposes"></a>

<span data-ttu-id="e7608-104">Komponenten, die über nutzen `IDataProtectionProvider` muss eine eindeutige übergeben *Zwecke* Parameter an die `CreateProtector` Methode.</span><span class="sxs-lookup"><span data-stu-id="e7608-104">Components which consume `IDataProtectionProvider` must pass a unique *purposes* parameter to the `CreateProtector` method.</span></span> <span data-ttu-id="e7608-105">Im Sinne *Parameter* ist für die Sicherheit der Datenschutzsystem integriert, da hiermit Isolation zwischen kryptografischen Consumern, selbst wenn der Stamm-Kryptografieschlüssel identisch sind.</span><span class="sxs-lookup"><span data-stu-id="e7608-105">The purposes *parameter* is inherent to the security of the data protection system, as it provides isolation between cryptographic consumers, even if the root cryptographic keys are the same.</span></span>

<span data-ttu-id="e7608-106">Wenn ein Consumer einen Zweck angegeben ist, den Zweck Zeichenfolge zusammen mit der Stamm-Kryptografieschlüssel dient zum eindeutigen kryptografischen Unterschlüssel Consumer abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="e7608-106">When a consumer specifies a purpose, the purpose string is used along with the root cryptographic keys to derive cryptographic subkeys unique to that consumer.</span></span> <span data-ttu-id="e7608-107">Dadurch wird den Consumer aus anderen kryptografischen Consumer in der Anwendung isoliert: keine andere Komponente die Nutzlasten lesen kann, und eine andere Komponente Nutzlasten nicht gelesen.</span><span class="sxs-lookup"><span data-stu-id="e7608-107">This isolates the consumer from all other cryptographic consumers in the application: no other component can read its payloads, and it cannot read any other component's payloads.</span></span> <span data-ttu-id="e7608-108">Diese Isolierung rendert auch unmöglich gesamte Kategorien von Angriff auf die Komponente.</span><span class="sxs-lookup"><span data-stu-id="e7608-108">This isolation also renders infeasible entire categories of attack against the component.</span></span>

![Beispiel für ein Diagramm Zweck](purpose-strings/_static/purposes.png)

<span data-ttu-id="e7608-110">In der Abbildung oben `IDataProtector` Instanzen A und B **kann nicht** Lesen des jeweils anderen Nutzlasten und nur ihre eigenen.</span><span class="sxs-lookup"><span data-stu-id="e7608-110">In the diagram above, `IDataProtector` instances A and B **cannot** read each other's payloads, only their own.</span></span>

<span data-ttu-id="e7608-111">Die Zweck Zeichenfolge keine geheim sein.</span><span class="sxs-lookup"><span data-stu-id="e7608-111">The purpose string doesn't have to be secret.</span></span> <span data-ttu-id="e7608-112">Dies sollte einfach insofern eindeutig sein, dass keine andere gut konzipierte Komponente immer den gleichen Zweck Zeichenfolge bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="e7608-112">It should simply be unique in the sense that no other well-behaved component will ever provide the same purpose string.</span></span>

>[!TIP]
> <span data-ttu-id="e7608-113">Unter Verwendung des Namespace und Typ der Komponente, die Datenschutz-APIs nutzen, ist eine gute Faustregel, wie in der Praxis, die diese Informationen nicht in Konflikt steht.</span><span class="sxs-lookup"><span data-stu-id="e7608-113">Using the namespace and type name of the component consuming the data protection APIs is a good rule of thumb, as in practice this information will never conflict.</span></span>
>
><span data-ttu-id="e7608-114">Eine Contoso autorisierten-Komponente, die für das trägertoken minting zuständig ist möglicherweise Contoso.Security.BearerToken als seine Zweck Zeichenfolge verwenden.</span><span class="sxs-lookup"><span data-stu-id="e7608-114">A Contoso-authored component which is responsible for minting bearer tokens might use Contoso.Security.BearerToken as its purpose string.</span></span> <span data-ttu-id="e7608-115">Oder es möglicherweise - sogar - Contoso.Security.BearerToken.v1 als seine Zweck Zeichenfolge verwenden.</span><span class="sxs-lookup"><span data-stu-id="e7608-115">Or - even better - it might use Contoso.Security.BearerToken.v1 as its purpose string.</span></span> <span data-ttu-id="e7608-116">Ermöglicht das Anfügen der Versionsnummer einer zukünftigen Version Contoso.Security.BearerToken.v2 als ihren Zweck zu verwenden, und die verschiedenen Versionen wäre vollständig voneinander isoliert, soweit Nutzlasten wechseln.</span><span class="sxs-lookup"><span data-stu-id="e7608-116">Appending the version number allows a future version to use Contoso.Security.BearerToken.v2 as its purpose, and the different versions would be completely isolated from one another as far as payloads go.</span></span>

<span data-ttu-id="e7608-117">Seit dem Zwecke Parameter `CreateProtector` ist ein Array von Zeichenfolgen, die oben genannten konnte stattdessen angegeben wurden als `[ "Contoso.Security.BearerToken", "v1" ]`.</span><span class="sxs-lookup"><span data-stu-id="e7608-117">Since the purposes parameter to `CreateProtector` is a string array, the above could have been instead specified as `[ "Contoso.Security.BearerToken", "v1" ]`.</span></span> <span data-ttu-id="e7608-118">Dies ermöglicht das Erstellen einer Hierarchie von Zwecken und mehrinstanzenfähigkeit Szenarios mit dem Data Protection System öffnet.</span><span class="sxs-lookup"><span data-stu-id="e7608-118">This allows establishing a hierarchy of purposes and opens up the possibility of multi-tenancy scenarios with the data protection system.</span></span>

<a name="data-protection-contoso-purpose"></a>

>[!WARNING]
> <span data-ttu-id="e7608-119">Nicht vertrauenswürdige Benutzereingaben als alleinige Quelle der Eingabe für die Zwecke Kette möglich Komponenten nicht.</span><span class="sxs-lookup"><span data-stu-id="e7608-119">Components should not allow untrusted user input to be the sole source of input for the purposes chain.</span></span>
>
><span data-ttu-id="e7608-120">Betrachten Sie beispielsweise eine Komponente Contoso.Messaging.SecureMessage, die zum Speichern von sicheren Nachrichten zuständig ist.</span><span class="sxs-lookup"><span data-stu-id="e7608-120">For example, consider a component Contoso.Messaging.SecureMessage which is responsible for storing secure messages.</span></span> <span data-ttu-id="e7608-121">Wären die sichere Messagingkomponente Aufrufen `CreateProtector([ username ])`, wird ein böswilliger Benutzer ein Konto mit dem Benutzernamen "Contoso.Security.BearerToken" in beim Abrufen der Komponente aufrufen, erstellt möglicherweise `CreateProtector([ "Contoso.Security.BearerToken" ])`, versehentlich wodurch sicheres messaging System MinZ Nutzlasten, die als Authentifizierungstoken wahrgenommen werden konnte.</span><span class="sxs-lookup"><span data-stu-id="e7608-121">If the secure messaging component were to call `CreateProtector([ username ])`, then a malicious user might create an account with username "Contoso.Security.BearerToken" in an attempt to get the component to call `CreateProtector([ "Contoso.Security.BearerToken" ])`, thus inadvertently causing the secure messaging system to mint payloads that could be perceived as authentication tokens.</span></span>
>
><span data-ttu-id="e7608-122">Eine bessere Zwecke-Kette für die Messagingkomponente wäre `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, die richtigen Isolation bietet.</span><span class="sxs-lookup"><span data-stu-id="e7608-122">A better purposes chain for the messaging component would be `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, which provides proper isolation.</span></span>

<span data-ttu-id="e7608-123">Die Isolierung durch und das Verhalten des `IDataProtectionProvider`, `IDataProtector`, und Zwecke lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="e7608-123">The isolation provided by and behaviors of `IDataProtectionProvider`, `IDataProtector`, and purposes are as follows:</span></span>

* <span data-ttu-id="e7608-124">Für einen angegebenen `IDataProtectionProvider` -Objekt, der `CreateProtector` Methode erstellt ein `IDataProtector` Objekt eindeutig gebunden, sowohl die `IDataProtectionProvider` Objekt, das erstellt hat und der Zwecke-Parameter an die Methode übergeben wurde.</span><span class="sxs-lookup"><span data-stu-id="e7608-124">For a given `IDataProtectionProvider` object, the `CreateProtector` method will create an `IDataProtector` object uniquely tied to both the `IDataProtectionProvider` object which created it and the purposes parameter which was passed into the method.</span></span>

* <span data-ttu-id="e7608-125">Der Zweck-Parameter darf nicht null sein.</span><span class="sxs-lookup"><span data-stu-id="e7608-125">The purpose parameter must not be null.</span></span> <span data-ttu-id="e7608-126">(Wenn Zwecke als Bytearray angegeben ist, bedeutet dies, dass das Array nicht der Länge Null sein darf und alle Elemente des Arrays müssen ungleich Null sein.) Ein leere Zeichenfolge Zweck ist technisch zulässig, wird jedoch abgeraten.</span><span class="sxs-lookup"><span data-stu-id="e7608-126">(If purposes is specified as an array, this means that the array must not be of zero length and all elements of the array must be non-null.) An empty string purpose is technically allowed but is discouraged.</span></span>

* <span data-ttu-id="e7608-127">Argumente für zwei Zwecke sind gleichwertig, wenn sie die gleichen Zeichenfolgen (über einen ordinalen Vergleich) in der gleichen Reihenfolge enthalten.</span><span class="sxs-lookup"><span data-stu-id="e7608-127">Two purposes arguments are equivalent if and only if they contain the same strings (using an ordinal comparer) in the same order.</span></span> <span data-ttu-id="e7608-128">Ein Argument für die einzelnen Zweck ist gleichbedeutend mit der entsprechenden Einzelelement-Zwecke Array.</span><span class="sxs-lookup"><span data-stu-id="e7608-128">A single purpose argument is equivalent to the corresponding single-element purposes array.</span></span>

* <span data-ttu-id="e7608-129">Zwei `IDataProtector` Objekte sind äquivalent, wenn sie über entsprechende erstellt werden `IDataProtectionProvider` Objekte mit den Parametern entspricht Zwecke.</span><span class="sxs-lookup"><span data-stu-id="e7608-129">Two `IDataProtector` objects are equivalent if and only if they are created from equivalent `IDataProtectionProvider` objects with equivalent purposes parameters.</span></span>

* <span data-ttu-id="e7608-130">Für einen bestimmten `IDataProtector` -Objekt, einen Aufruf von `Unprotect(protectedData)` zurück, wird der ursprüngliche `unprotectedData` nur, wenn `protectedData := Protect(unprotectedData)` ein entsprechendes `IDataProtector` Objekt.</span><span class="sxs-lookup"><span data-stu-id="e7608-130">For a given `IDataProtector` object, a call to `Unprotect(protectedData)` will return the original `unprotectedData` if and only if `protectedData := Protect(unprotectedData)` for an equivalent `IDataProtector` object.</span></span>

> [!NOTE]
> <span data-ttu-id="e7608-131">Wir sind nicht die Groß-/Kleinschreibung in Erwägung ziehen, in denen eine Komponente absichtlich eine Zeichenfolge Zweck wählt was einen Konflikt mit einer anderen Komponente bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="e7608-131">We're not considering the case where some component intentionally chooses a purpose string which is known to conflict with another component.</span></span> <span data-ttu-id="e7608-132">Eine solche Komponente im Wesentlichen betrachtet werden böswillige, und dieses System ist nicht vorgesehen, Sicherheitsgarantien angeben, dass bösartiger Code innerhalb der Arbeitsprozess bereits ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="e7608-132">Such a component would essentially be considered malicious, and this system is not intended to provide security guarantees in the event that malicious code is already running inside of the worker process.</span></span>
